import { createClient, SupabaseClient } from '@supabase/supabase-js';
import * as fs from 'fs';
import * as path from 'path';
import * as dotenv from 'dotenv';

// Charger les variables d'environnement
dotenv.config();

// Configuration Supabase
const SUPABASE_URL = process.env.SUPABASE_URL || 'http://localhost:54321';
const SUPABASE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY || 
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImV4cCI6MTk4MzgxMjk5Nn0.EGIM96RAZx35lJzdJsyH-qQwv8Hdp7fsn3W0YpN81IU';

// Cr√©ation de la table de migrations si elle n'existe pas
async function ensureMigrationsTable() {
  const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);
  
  console.log('üîÑ V√©rification de la table migrations...');
  
  const { error } = await supabase
    .from('_migrations_init')
    .select('*')
    .limit(1)
    .then(async () => {
      // La table n'existe pas, on cr√©e d'abord la table migrations
      return supabase
        .query(`
          CREATE TABLE IF NOT EXISTS migrations (
            id SERIAL PRIMARY KEY,
            name VARCHAR(255) NOT NULL UNIQUE,
            executed_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
          );
        `);
    })
    .catch(async () => {
      // Erreur attendue, on cr√©e la table migrations
      return supabase
        .query(`
          CREATE TABLE IF NOT EXISTS migrations (
            id SERIAL PRIMARY KEY,
            name VARCHAR(255) NOT NULL UNIQUE,
            executed_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
          );
        `);
    });
  
  if (error) {
    console.error('‚ùå Erreur lors de la cr√©ation de la table migrations:', error);
    process.exit(1);
  }
  
  console.log('‚úÖ Table migrations pr√™te');
}

// R√©cup√©ration des migrations d√©j√† ex√©cut√©es
async function getAppliedMigrations() {
  const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);
  
  const { data, error } = await supabase
    .from('migrations')
    .select('name')
    .order('id', { ascending: true });
  
  if (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des migrations appliqu√©es:', error);
    return [];
  }
  
  return data.map(row => row.name);
}

// Ex√©cution d'une migration
async function runMigration(migrationName: string, filePath: string) {
  const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);
  
  console.log(`üîÑ Ex√©cution de la migration: ${migrationName}`);
  
  try {
    // Lecture du fichier SQL
    const sql = fs.readFileSync(filePath, 'utf8');
    
    // Ex√©cution du SQL
    const { error: migrationError } = await supabase.rpc('pg_dump', { 
      query: sql,
      params: [] 
    });
    
    if (migrationError) {
      console.error(`‚ùå Erreur lors de l'ex√©cution de la migration ${migrationName}:`, migrationError);
      return false;
    }
    
    // Enregistrement de la migration appliqu√©e
    const { error: recordError } = await supabase
      .from('migrations')
      .insert([{ name: migrationName }]);
    
    if (recordError) {
      console.error(`‚ùå Erreur lors de l'enregistrement de la migration ${migrationName}:`, recordError);
      return false;
    }
    
    console.log(`‚úÖ Migration appliqu√©e: ${migrationName}`);
    return true;
  } catch (error) {
    console.error(`‚ùå Erreur lors de l'ex√©cution de la migration ${migrationName}:`, error);
    return false;
  }
}

// Fonction principale pour ex√©cuter toutes les migrations
async function migrate() {
  try {
    // S'assurer que la table de migrations existe
    await ensureMigrationsTable();
    
    // R√©cup√©rer les migrations d√©j√† appliqu√©es
    const appliedMigrations = await getAppliedMigrations();
    console.log(`‚ÑπÔ∏è ${appliedMigrations.length} migrations d√©j√† appliqu√©es`);
    
    // R√©cup√©rer toutes les migrations dans le dossier
    const migrationsDir = path.join(__dirname, '..', 'migrations');
    const migrationFiles = fs.readdirSync(migrationsDir)
      .filter(file => file.endsWith('.sql'))
      .sort(); // Tri alphab√©tique pour garantir l'ordre d'ex√©cution
    
    console.log(`‚ÑπÔ∏è ${migrationFiles.length} fichiers de migration trouv√©s`);
    
    // Filtrer les migrations non encore appliqu√©es
    const pendingMigrations = migrationFiles.filter(file => !appliedMigrations.includes(file));
    
    if (pendingMigrations.length === 0) {
      console.log('‚úÖ Toutes les migrations sont d√©j√† appliqu√©es');
      return;
    }
    
    console.log(`‚ÑπÔ∏è ${pendingMigrations.length} migrations √† appliquer`);
    
    // Ex√©cuter les migrations en s√©quence
    let success = true;
    for (const migration of pendingMigrations) {
      const migrationPath = path.join(migrationsDir, migration);
      const result = await runMigration(migration, migrationPath);
      
      if (!result) {
        success = false;
        break;
      }
    }
    
    if (success) {
      console.log('‚úÖ Toutes les migrations ont √©t√© appliqu√©es avec succ√®s');
    } else {
      console.error('‚ùå Le processus de migration a √©chou√©');
      process.exit(1);
    }
  } catch (error) {
    console.error('‚ùå Erreur lors du processus de migration:', error);
    process.exit(1);
  }
}

// Ex√©cuter les migrations
migrate();
